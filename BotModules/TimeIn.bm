package BotModules::TimeIn;
use strict;
use base 'BotModules';

use DateTime;
use Mojo::JSON qw( decode_json );
use Mojo::URL;

sub Initialise {
    my $self = shift;
    $self->{dbh} = $self->sqlite();
    $self->{dbh}->do("CREATE TABLE IF NOT EXISTS places(address CHAR, name CHAR, timezone CHAR)");
    $self->{dbh}->do("CREATE UNIQUE INDEX IF NOT EXISTS places_idx ON places(address COLLATE NOCASE)");
}

sub Unload {
    my $self = shift;
    delete $self->{dbh};
}

sub RegisterConfig {
    my $self = shift;
    $self->SUPER::RegisterConfig(@_);
    $self->registerVariables(
      # [ name, save?, settable?, value ]
        ['apiKey', 1, 1, ''],
    );
}

sub Told {
    my ($self, $event, $message) = @_;

    if ($self->{apiKey} && $message =~ /^time\s+in\s+(.+)$/i) {
        my $address = $1;
        $address =~ s/(^\s+|\s+$)//g;
        $address =~ s/\s+/ /g;

        my $cached = $self->{dbh}->selectrow_hashref(
            "SELECT address,name,timezone FROM places WHERE address LIKE ?",
            undef,
            $address,
        );
        if ($cached) {
            $self->time_in($event, $cached);
            return 0;
        }

        my $url = Mojo::URL->new('https://maps.googleapis.com/maps/api/geocode/json');
        $url->query(
            key => $self->{apiKey},
            address => $address,
        );
        $self->getURI($event, $url->to_string, { state => 'geocode', address => $address });
        return 0;
    }

    return $self->SUPER::Told(@_);
}

sub GotURI {
    my ($self, $event, $uri, $output, $params) = @_;

    my @response;
    if ($params->{state} eq 'geocode') {
        eval {
            my $result = decode_json($output);
            die "geocode: bad status\n" unless $result->{status} eq 'OK';
            my $results = $result->{results};
            die "geocode: no results\n" unless @$results;
            $params->{name} = $results->[0]->{formatted_address};
            $params->{lat} = detaint_float($results->[0]->{geometry}->{location}->{lat});
            $params->{lng} = detaint_float($results->[0]->{geometry}->{location}->{lng});
        };
        if ($@) {
            push @response, "Unable to determine time in '" . $params->{address} . "'";
            # push @response, $@; # debugging
        } else {
            my $url = Mojo::URL->new('https://maps.googleapis.com/maps/api/timezone/json');
            $url->query(
                key => $self->{apiKey},
                location => $params->{lat} . ',' . $params->{lng},
                timestamp => time(),
            );
            $params->{state} = 'timezone';
            $self->getURI($event, $url->to_string, $params);
        }

    } elsif ($params->{state} eq 'timezone') {
        eval {
            my $result = decode_json($output);
            die "timezone: bad status\n" unless $result->{status} eq 'OK';
            $params->{timezone} = $result->{timeZoneId};
        };
        if ($@) {
            push @response, "Unable to determine time in '" . $params->{address} . "'";
        } else {
            $self->{dbh}->do(
                "INSERT INTO places(address,name,timezone) VALUES(?,?,?)",
                undef,
                $params->{address}, $params->{name}, $params->{timezone},
            );
            $self->time_in($event, $params);
            return;
        }
    }
    if (@response) {
        $self->say($event, $event->{from} . ': ' . join(' ', @response));
    }
}

sub time_in {
    my ($self, $event, $params) = @_;
    my $dt;
    eval {
        $dt = DateTime->now->set_time_zone($params->{timezone});
    };
    if ($@) {
        $self->say(
            $event,
            sprintf(
                "%s: Unable to determine time in '%s'",
                $event->{from},
                $params->{address},
            )
        );
    } else {
        $self->say(
            $event,
            sprintf(
                '%s: It is %s in %s',
                $event->{from},
                lc($dt->format_cldr('h:mma')),
                $params->{name},
            )
        );
    }
}

sub detaint_float {
    my ($f) = @_;
    return 0 unless $f =~ /^(-?\d+(?:\.\d+)?)$/;
    return $1;
}

1;
